---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---
Original Table 2 - Testing Cooper et al. Measurement Error Approach
```{r}
library(geiger)
library(reshape)
library(diversitree)
library(motmot)
#tips<-c(25)
#tips<-c(500)
tips<-c(25,50,75,100,200,500)
tree.num<-50
nsim<-20

#tree.num<-1000

#For b/d loops
#errors<-c(0.001)
#errors<-c(0.25)
errors<-c(0.01,0.05,0.10,0.25)
#lambdas<-c(0.1,0.1,0.1,0.1)
#mus<-c
#mus<-c(0.0,0.025,0.05,0.075)
sigma2<-1.0
quantiles <- c(0.025, 0.975)
error.stats<-data.frame(matrix(NA, ncol=3,nrow = tree.num))
#names(error.stats)<-c("Tips",errors)
#error.stats$Tips<-tips
saved.reject.rate<-NULL
bm_mod<-NULL
ou_mod<-NULL
error.list<-list()
saved.error.stats<-NULL
for(j in 1:length(tips)){
  for(k in 1:length(errors)){
    #print(errors[k])
    reject.rate<-NULL
    saved.within.groups<-NULL
      for(x in 1:tree.num){
        print(paste(tips[j],errors[k],x))
        ext.tips<-data.frame(matrix(NA,nrow=tips[j],ncol=nsim))
        row.names(ext.tips)<-1:tips[j]
        colnames(ext.tips)<-1:nsim
        tr <- sim.bdtree(b = 1, d = 0, stop = "taxa", n = tips[j]) #Using geiger function
        #tr <- trees(pars = c(lambda=1, mu=0), type = "bd", n = 1, max.taxa = tips[j], max.t = 10)
        #tr<-tr[[1]] #Using diversitree as in original ms
        #org.tr<-tr #Saving original tree
        #tr$edge.length<-tr$edge.length/max(branching.times(tr))
        dat<-sim.char(phy=tr,par=sigma2,model="BM",root=0) #Simulate trait data using geiger
        dat<-as.matrix(dat[,,1])
        times <- errors[k]*max(node.depth.edgelength(tr)) #Get order of edges leading to tips, then add on some distances in branches of tips
        #times <- tr$edge.length[match(1:Ntip(tr), tr$edge[,2])] + errors[k]*max(node.depth.edgelength(tr)) #Get order of edges leading to tips, then add on some distances in branches of tips

        for(i in 1:nsim){
          for(l in 1:tips[j]){
            ext.tips[l,i]<-rnorm(n=1,mean=dat[l],sd=sqrt(sigma2*times))    
            }
          
          dummy.data<-as.matrix(ext.tips[,i])
          row.names(dummy.data)<-tr$tip.label
          
          #bm_mod <- c(bm_mod,transformPhylo.ML(dat, tr, model="bm", modelCIs=FALSE)) #Fit likelihood models - BM
          #ou_mod <- c(ou_mod,transformPhylo.ML(dat, tr,model="OU", modelCIs=FALSE))	#Fit likelihood models - OU

          bm_mod <- transformPhylo.ML(dummy.data, tr, model="bm", modelCIs=FALSE) #Fit likelihood models - BM
          ou_mod <- transformPhylo.ML(dummy.data, tr,model="OU", modelCIs=FALSE)	#Fit likelihood models - OU
          reject.rate<-c(reject.rate,if(2*(ou_mod$MaximumLikelihood - bm_mod$logLikelihood)>3.84){"Reject"}else{"Accept"})
          #print(reject.rate)
          }
          ##############################
          me.data.frame<-as.data.frame(ext.tips)
          me.data.frame<-cbind(me.data.frame,"ID"=row.names(me.data.frame))
          me.data.frame <- melt(me.data.frame, id=c("ID"))
          #print(me.data.frame)
          lm.result<-lm(value~ID,data=me.data.frame)
          anova.result<-anova(lm.result)
          among<-(anova.result[1,3]-anova.result[2,3])/nsim
          within<-anova.result[2,3]
          among.groups<-among/(within+among)*100
          within.groups<-within/(within+among)*100
          saved.within.groups<-c(saved.within.groups,within.groups)
          
          }
    
    saved.reject.rate<-length(grep("Reject", reject.rate))/(nsim*tree.num)
    error.stats<-median(saved.within.groups)
    error.stats<-c(error.stats,quantile(saved.within.groups,quantiles))  

    #error.stats<-mean(saved.within.groups)
    #error.stats<-c(error.stats,range(saved.within.groups))
    saved.error.stats<-rbind(saved.error.stats,c(tips[j],errors[k],error.stats,saved.reject.rate))
  }
}
  #mean(apply(ext.tips,1,sd)/dat*100)
  saved.error.stats<-as.data.frame(saved.error.stats)
  names(saved.error.stats)<-c("Tips","Error=","Median ME","5%","95%","Rejection Rate")
  saved.error.stats
  #matplot(t(ext.tips),type="l",lty=1)

```

